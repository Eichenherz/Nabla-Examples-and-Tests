#ifndef _NBL_GLSL_WORKGROUP_SIZE_
#define _NBL_GLSL_WORKGROUP_SIZE_ 256
#endif
layout(local_size_x=_NBL_GLSL_WORKGROUP_SIZE_, local_size_y=1, local_size_z=1) in;
 
#define _NBL_GLSL_EXT_FFT_GET_PARAMETERS_DEFINED_
#define _NBL_GLSL_EXT_FFT_SET_DATA_DEFINED_
#define _NBL_GLSL_EXT_FFT_GET_PADDED_DATA_DEFINED_
#include "nbl/builtin/glsl/ext/FFT/fft.glsl"

// Input Descriptor

layout(set=0, binding=0) readonly restrict buffer InputBuffer
{
	nbl_glsl_complex inData[];
};

// Output Descriptor

layout(set=0, binding=1, rgba16f) uniform image2D outImage;

// Get/Set Data Function

layout(push_constant) uniform PushConstants
{
	nbl_glsl_ext_FFT_Parameters_t params;
} pc;

 nbl_glsl_ext_FFT_Parameters_t nbl_glsl_ext_FFT_getParameters() {
	 nbl_glsl_ext_FFT_Parameters_t ret;
	 ret = pc.params;
	 return ret;
 }

void nbl_glsl_ext_FFT_setData(in uvec3 coordinate, in uint channel, in nbl_glsl_complex complex_value)
{
	const ivec2 coords = ivec2(coordinate.xy);

    vec4 color_value = imageLoad(outImage, coords);
    color_value[channel] = complex_value.x;
    imageStore(outImage, coords, color_value);
}

nbl_glsl_complex nbl_glsl_ext_FFT_getPaddedData(in uvec3 coordinate, in uint channel) 
{
	uvec4 strided = nbl_glsl_ext_FFT_Parameters_t_getInputStrides()*uvec4(coordinate,channel);
	return inData[strided.x+strided.y+strided.z+strided.w];
}

void main()
{
    const uint numChannels = nbl_glsl_ext_FFT_Parameters_t_getNumChannels();
	for(uint ch = 0u; ch < numChannels; ++ch)
	{
		nbl_glsl_ext_FFT(true, ch);
	}
}